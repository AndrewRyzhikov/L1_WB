Устные вопросы

Какой самый эффективный способ конкатенации строк?

Ответ: strings.Builder

Что такое интерфейсы, как они применяются в Go?

Ответ: Интерфейс в Go - это контракт. Структура удовлетворяет интерфейсу (выполняет контракт), если реализует все методы объявленные в интерфейсе.

Чем отличаются RWMutex от Mutex?

Ответ: RWMutex позволяет горутинам читать данные из объекта без блокировки остальных горутин.

Чем отличаются буферизированные и небуферизированные каналы?

Ответ: небуферизированный канал блокируется после записи до момента, пока из канала не произойдёт чтение, буферезированный не заблокируется пока не будет заполнен буфер.

Какой размер у структуры struct{}{}?

Ответ: 0 байт.

Есть ли в Go перегрузка методов или операторов?

Ответ: нет перегрузки методов или операторов.

В какой последовательности будут выведены элементы map[int]int?

Ответ: вывод элементов из map не детерминирован, возможны различные последовательности.

В чем разница make и new?

Ответ: 
Типы объектов:
    new выделяет память для любых типов данных и возвращает указатель на эту память.
    make используется только для создания и инициализации срезов, карт и каналов и возвращает готовый к использованию объект.
Возвращаемое значение:
    new возвращает указатель на объект.
    make возвращает сам объект.
Инициализация:
    new только выделяет память и инициализирует её нулевым значением.
    make не только выделяет память, но и выполняет дополнительную инициализацию, необходимую для полноценного использования объектов срезов, карт и каналов. 

Сколько существует способов задать переменную типа slice или map?

Ответ: make, new, присваивание через := и = .

Что выведет данная программа и почему?

func update(p *int) {
b := 2
p = &b
}

func main() {
var (
a = 1
p = &a
)
fmt.Println(*p)
update(p)
fmt.Println(*p)
}

Ответ: Первый fmt.Println(*p) выведет 1 и второй fmt.Println(*p) выведет 1. Функция update не изменила значению по указателю p *int. В Go аргументы передаются по значению, поэтому p *int в функции update это копия адреса в памяти где записана единица, в переменную p *int в функции update был записан адрес новой переменной b, а не измененно значение лежащее по адресу в памяти.

Что выведет данная программа и почему?
func main() {
wg := sync.WaitGroup{}
for i := 0; i < 5; i++ {
wg.Add(1)
go func(wg sync.WaitGroup, i int) {
fmt.Println(i)
wg.Done()
}(wg, i)
}
wg.Wait()
fmt.Println("exit")
}

Ответ: Порядок вывода от 0 до 4 не детерминирован, поскольку паралельное исполнение горутин не детерминировано, нельзя заранее сказать, какие горутины выполнятся быстрее. После программа свалится с дедлоком из-за того что sync.WaitGroup передаётся по значению.

Что выведет данная программа и почему?
func main() {
n := 0
if true {
n := 1
n++
}
fmt.Println(n)
}

Ответ: Выведет 0. Внутри условия создаётся новая переменная n со своей областью видимости, именно она инкрементируется, переменная n вне скоупа условия не изменяется.

Что выведет данная программа и почему?
func someAction(v []int8, b int8) {
v[0] = 100
v = append(v, b)
}

func main() {
var a = []int8{1, 2, 3, 4, 5}
someAction(a, 6)
fmt.Println(a)
}

Ответ: Будет выведено [100 2 3 4 5]. В Go аргументы передаются по значению, то есть в функцию someAction передана копия слайся a. И копия слайса v в функции someAction и слайс a ссылаются на один и тот же массив, поэтому первое его значение будет перезаписано с 1 на 100. Затем в слайс v добавляется число 6, под slice v пересоздаётся массив, увеличится cap и len слайся v, но значение cap, len и указатель на массив у слайся a остаются прежними.

Что выведет данная программа и почему?
func main() {
slice := []string{"a", "a"}

func(slice []string) {
slice = append(slice, "a")
slice[0] = "b"
slice[1] = "b"
fmt.Print(slice)
}(slice)
fmt.Print(slice)
}

Ответ: Первый fmt.Println(slice) внутри функции выведет [b b a], второй fmt.Println(slice) в main выведет [a a]. len = 2 и cap = 2 у slice в main, у переданной копии в функцию тоже len = 2 и cap = 2, но для добавления нового элемента не хватает cap, поэтому при вставке нового элемента аллоцируется новый массив и cap увеличивается в 2 раза. Значения с индексом 0 и 1 в новом массиве перезаписываются, вывод [b b a]. Затем выводится slice в main, но он ссылается на другой (исходный) массив, поэтому выводится [a a].
